<!doctype html>
<!--
Copyright 2017 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>

    <title>Reduced Bind Rendering</title>

    <link href='css/common.css' rel='stylesheet'></link>

    <script src='js/third-party/gl-matrix-min.js'></script>

    <script src='js/third-party/wglu/wglu-program.js'></script>
    <script src='js/third-party/wglu/wglu-stats.js'></script>
    <script src='js/third-party/wglu/wglu-texture.js'></script>

    <script src='js/webvr-button.js'></script>
    <script src='js/webvr-scene.js'></script>
    <script src='js/webvr-scene-cube-sea.js'></script>
    <script src='js/webvr-samples-util.js'></script>
  </head>
  <body>
    <header>
      <h1>Reduced Bind Rendering</h1>
      <p>
        This sample demonstrates a simple technique to reduce the number of
        state changes an application needs to make while rendering, potentially
        enabling better performance.
      </p>
    </header>
    <script>
      (function () {
      'use strict';

      // VR globals.
      let vrButton = null;
      let vrExclusiveFrameOfRef = null;
      let vrNonExclusiveFrameOfRef = null;

      // WebGL scene globals.
      let gl = null;
      let scene = new WebVRSceneCubeSea();

      function initVR() {
        vrButton = new VRDeviceButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession
        });
        document.querySelector('header').appendChild(vrButton.domElement);

        if (navigator.vr) {
          navigator.vr.getDevices().then((devices) => {
            for (let device of devices) {
              vrButton.addDevice(device);
            }
            
            if (!devices.length)
              return;

            let outputCanvas = document.createElement('canvas');
            let ctx = outputCanvas.getContext('vrpresent');

            devices[0].requestSession({ outputContext: ctx })
                .then((session) => {
                  document.body.appendChild(outputCanvas);
                  onSessionStarted(session);
                });
          });
        }
      }

      function onRequestSession(device) {
        device.requestSession({ exclusive: true }).then((session) => {
          vrButton.setSession(session);
          onSessionStarted(session);
        });
      }

      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);

        if (!gl) {
          gl = VRSamplesUtil.initWebGLContext({
            compatibleVrDevice: session.device
          });

          scene.setWebGLContext(gl);
        }

        session.baseLayer = new VRWebGLLayer(session, gl);

        session.requestFrameOfReference('eyeLevel').then((frameOfRef) => {
          if (session.exclusive) {
            vrExclusiveFrameOfRef = frameOfRef;
          } else {
            vrNonExclusiveFrameOfRef = frameOfRef;
          }
          session.requestFrame(onVRFrame);
        });
      }

      function onEndSession(session) {
        session.end();
      }

      function onSessionEnded(event) {
        if (event.session.exclusive)
          vrButton.setSession(null);
      }

      function onVRFrame(frame) {
        let session = frame.session;
        let frameOfRef = session.exclusive ?
                         vrExclusiveFrameOfRef :
                         vrNonExclusiveFrameOfRef;
        let pose = frame.getDevicePose(frameOfRef);

        scene.startFrame();

        session.requestFrame(onVRFrame);

        gl.bindFramebuffer(gl.FRAMEBUFFER, session.baseLayer.framebuffer);
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        if (pose) {
          // This is a different rendering pattern than the previous samples
          // used, but it should be more efficent. It's very common for apps
          // being ported to VR to take existing 2D rendering code and call the
          // top-level "drawScene" function once per VR view, effectively
          // drawing a single eye at a time. However, this causes many state
          // changes to be duplicated, which adds to the render loop's overhead.
          // By providing the matrices and viewports as an array to the drawing
          // function it can do all the necessary binding once and then call the
          // actual draw commands in a tighter loop, only changing the matrices
          // and viewport each time. This does mean that the viewport is changed
          // much more frequently (N times per object instead of N times per
          // scene) but it's typically a pretty cheap thing to change and will
          // almost always be easily outweighed by the savings from not
          // redundantly binding everything else.

          // For example, a traditional draw loop would do this:

          // Draw(views):
          //   for each view in views:
          //     setViewport();
          //     for each object in scene:
          //       bindProgram();
          //       bindMatrices();
          //       bindUniforms();
          //       bindBuffers();
          //       bindTextures();
          //       draw();

          // While this method results in a loop more like this:

          // Draw(views):
          //   for each object in scene:
          //     bindProgram();  
          //     bindUniforms();
          //     bindBuffers();
          //     bindTextures();
          //     for each view in views:
          //       setViewport();
          //       bindMatrices();
          //       draw();

          // Note that for the complexity of the scene in this samples this
          // won't make much visible performance difference, but we're using the
          // more efficient pattern anyway as a way of promoting best practices.

          let views = [];
          for (let view of frame.views) {
            // Gather all the values needed for one view and push it into the
            // array of views to be drawn. WebVRView is a utility class defined
            // by webvr-scene.js that holds all the necessary values for drawing
            // a single view.
            let render_view = new WebVRView();

            // In future samples we'll hide this part away as well by using the
            // scene.drawVRViews() function, which handles gathering these
            // values internally.
            render_view.projection_mat = view.projectionMatrix;
            render_view.view_mat = pose.getViewMatrix(view);
            render_view.viewport = view.getViewport(session.baseLayer);
            views.push(render_view);
          }

          scene.drawViewArray(views);
        }

        scene.endFrame();
      }

      initVR();
      })();
    </script>
  </body>
</html>
