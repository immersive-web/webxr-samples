<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>

    <title>AR Plane Detection</title>

    <link href='../css/common.css' rel='stylesheet'></link>

  </head>
  <body>
    <header>
      <details open>
        <summary>AR Plane Detection with Anchors</summary>
        This sample demonstrates using the Plane Detection feature with Anchors,
        including implementation of synchronous hit test in JavaScript
        leveraging obtained plane data and anchors API to position objects.
        <p>
          <input id="usePlaneOrigin" type="checkbox" checked>
          <label for="usePlaneOrigin">Plane coordinate system visible</label><br/>

          <input id="useDomOverlay" type="checkbox" checked>
          <label for="useDomOverlay">Enable DOM Overlay</label><br/>

          <a class="back" href="./index.html">Back</a>
        </p>
      </details>
    </header>

    <script type="module">
      import * as THREE from 'https://unpkg.com/three@0.127.0/build/three.module.js';
      import {WebXRButton} from '../js/util/webxr-button.js';

      let xrButton = null;

      let container;
      let camera, scene, renderer;
      let controller;

      let reticle;

      let planeMaterials = [];

      let hitTestSource = null;
      let hitTestSourceRequested = false;

      init();
      // animate();

      function init() {

        container = document.createElement( 'div' );
        document.body.appendChild( container );

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera( 70, window.innerWidth / window.innerHeight, 0.01, 20 );

        const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
        light.position.set( 0.5, 1, 0.25 );
        scene.add( light );

        renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.xr.enabled = true;
        renderer.autoClear = false;
        container.appendChild( renderer.domElement );

        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession,
          textEnterXRTitle: "START AR",
          textXRNotFoundTitle: "AR NOT FOUND",
          textExitXRTitle: "EXIT AR",
        });

        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.isSessionSupported('immersive-ar')
                      .then((supported) => {
            xrButton.enabled = supported;
          });
        }
        
        const geometry = new THREE.CylinderGeometry( 0.1, 0.1, 0.2, 32 ).translate( 0, 0.1, 0 );

        const onSelect = function() {
          if ( reticle.visible ) {
            const material = new THREE.MeshPhongMaterial( { color: 0xffffff * Math.random() } );
            const mesh = new THREE.Mesh( geometry, material );
            mesh.position.setFromMatrixPosition( reticle.matrix );
            mesh.scale.y = Math.random() * 2 + 1;
            scene.add( mesh );
          }
        }

        controller = renderer.xr.getController( 0 );
        controller.addEventListener( 'select', onSelect );
        scene.add( controller );

        reticle = new THREE.Mesh(
          new THREE.RingGeometry( 0.15, 0.2, 32 ).rotateX( - Math.PI / 2 ),
          new THREE.MeshBasicMaterial()
        );
        reticle.matrixAutoUpdate = false;
        reticle.visible = false;
        scene.add( reticle );

        const loadManager = new THREE.LoadingManager();
        const loader = new THREE.TextureLoader(loadManager);
        const gridTexture = loader.load('https://raw.githubusercontent.com/google-ar/arcore-android-sdk/c684bbda37e44099c273c3e5274fae6fccee293c/samples/hello_ar_c/app/src/main/assets/models/trigrid.png');
        gridTexture.wrapS = THREE.RepeatWrapping;
        gridTexture.wrapT = THREE.RepeatWrapping;

        const createPlaneMaterial = (params) => 
          new THREE.MeshBasicMaterial(Object.assign(params, {
            map: gridTexture,
            opacity: 0.5,
            transparent: true,
          }));
        planeMaterials.push(createPlaneMaterial({color: 0xff0000}));
        planeMaterials.push(createPlaneMaterial({color: 0x00ff00}));
        planeMaterials.push(createPlaneMaterial({color: 0x0000ff}));
        planeMaterials.push(createPlaneMaterial({color: 0xffff00}));
        planeMaterials.push(createPlaneMaterial({color: 0x00ffff}));
        planeMaterials.push(createPlaneMaterial({color: 0xff00ff}));

        //
        window.addEventListener( 'resize', onWindowResize );
      }

      function onRequestSession() {
        let sessionInit = {
          requiredFeatures: ['anchors', 'plane-detection', 'hit-test'],
          optionalFeatures: [],
        };
        if (useDomOverlay.checked) {
          sessionInit.optionalFeatures.push('dom-overlay');
          sessionInit.domOverlay = {root: document.body};
        }
        navigator.xr.requestSession('immersive-ar', sessionInit).then((session) => {
          session.mode = 'immersive-ar';
          xrButton.setSession(session);
          onSessionStarted(session);
        });
      }

      function onSessionStarted(session) {
        useDomOverlay.disabled = true;
        session.addEventListener( 'end', onSessionEnded );

        renderer.xr.setReferenceSpaceType( 'local' );
        renderer.xr.setSession( session );

        renderer.setAnimationLoop( render );
      }

      function onEndSession(session) {
        session.end();
      }

      function onSessionEnded(event) {
        useDomOverlay.disabled = false;
        xrButton.setSession(null);

        renderer.setAnimationLoop(null);
        renderer.xr.setSession(null)
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );
      }

      function animate() {
        renderer.setAnimationLoop( render );
      }

      let anchorId = 1;
      let allAnchors = new Map();
      function processAnchors(timestamp, frame) {
        if(frame.trackedAnchors) {
          allAnchors.forEach((anchorContext, anchor) => {
            if(!frame.trackedAnchors.has(anchor)) {
              // anchor was removed
              allAnchors.delete(anchor);
              console.debug("Anchor no longer tracked, id=" + anchorContext.id);
            }
          });

          frame.trackedAnchors.forEach(anchor => {
            if(allAnchors.has(anchor)) {
              const anchorContext = allAnchors.get(anchor);
              // update pose
            } else {
              // new anchor
              allAnchors.set(plane, {id: anchorId});
              console.debug("New anchor created, id=" + anchorId);
              anchorId++;
            }
          });
        }
      }

      function createGeometryFromPolygon(polygon) {
        const geometry = new THREE.BufferGeometry();

        const vertices = [];
        const uvs = [];
        polygon.forEach(point => {
          vertices.push(point.x, point.y, point.z);
          uvs.push(point.x, point.z);
        })

        const indices = [];
        for(let i = 2; i < polygon.length; ++i) {
          indices.push(0, i-1, i);
        }

        geometry.setAttribute('position',
          new THREE.BufferAttribute(new Float32Array(vertices), 3));
        geometry.setAttribute('uv',
          new THREE.BufferAttribute(new Float32Array(uvs), 2))
        geometry.setIndex(indices);

        return geometry;
      }

      let planeId = 1;
      let allPlanes = new Map();
      function processPlanes(timestamp, frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();

        if(frame.detectedPlanes) {
          allPlanes.forEach((planeContext, plane) => {
            if(!frame.detectedPlanes.has(plane)) {
              // plane was removed
              allPlanes.delete(plane);
              console.debug("Plane no longer tracked, id=" + planeContext.id);

              scene.remove(planeContext.mesh);
            }
          });

          frame.detectedPlanes.forEach(plane => {
            const planePose = frame.getPose(plane.planeSpace, referenceSpace);

            if(allPlanes.has(plane)) {
              // may have been updated:
              const planeContext = allPlanes.get(plane);
              if(planeContext.timestamp < plane.lastChangedTime) {
                // updated!
                planeContext.timestamp = plane.lastChangedTime;

                // scene.remove(planeContext.mesh);

                const geometry = createGeometryFromPolygon(plane.polygon);
                planeContext.mesh.geometry.dispose();
                planeContext.mesh.geometry = geometry;
                
                // const planeMesh = new THREE.Mesh(geometry,
                //   planeMaterials[planeId % planeMaterials.length]
                // );
                  
                // planeMesh.matrixAutoUpdate = false;
                // planeMesh.visible = true;
                  
                // scene.add(planeMesh);

                // planeContext.mesh = planeMesh;
              }

              planeContext.mesh.matrix.fromArray(planePose.transform.matrix);

              // allPlanes.set(plane, planeContext);
            } else {
              // new plane
              const planeContext = {
                id: planeId,
                timestamp: plane.lastChangedTime,
              };
              
              const geometry = createGeometryFromPolygon(plane.polygon);
              const planeMesh = new THREE.Mesh(geometry,
                planeMaterials[planeId % planeMaterials.length]
              );
              
              planeMesh.matrixAutoUpdate = false;
              planeMesh.visible = true;

              planeMesh.matrix.fromArray( planePose.transform.matrix );

              scene.add(planeMesh);
              planeContext.mesh = planeMesh;

              allPlanes.set(plane, planeContext);
              console.debug("New plane detected, id=" + planeId);
              planeId++;
            }
          });
        }
      }

      function render( timestamp, frame ) {
        if ( frame ) {
          processAnchors(timestamp, frame);
          processPlanes(timestamp, frame);

          const referenceSpace = renderer.xr.getReferenceSpace();
          const session = renderer.xr.getSession();

          if ( hitTestSourceRequested === false ) {
            session.requestReferenceSpace( 'viewer' ).then( function ( referenceSpace ) {
              session.requestHitTestSource( { space: referenceSpace } ).then( function ( source ) {
                hitTestSource = source;
              } );
            } );

            session.addEventListener( 'end', function () {
              hitTestSourceRequested = false;
              hitTestSource = null;
            } );

            hitTestSourceRequested = true;
          }

          if ( hitTestSource ) {
            const hitTestResults = frame.getHitTestResults( hitTestSource );

            if ( hitTestResults.length ) {
              const hit = hitTestResults[ 0 ];

              reticle.visible = true;
              reticle.matrix.fromArray( hit.getPose( referenceSpace ).transform.matrix );
            } else {
              reticle.visible = false;
            }
          }
          renderer.render( scene, camera );
        }
      }

    </script>
  </body>
</html>
