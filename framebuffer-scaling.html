<!doctype html>
<!--
Copyright 2017 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>

    <title>Framebuffer Scaling</title>

    <link href='css/common.css' rel='stylesheet'></link>

    <script src='js/third-party/gl-matrix-min.js'></script>

    <script src='js/third-party/wglu/wglu-program.js'></script>
    <script src='js/third-party/wglu/wglu-stats.js'></script>
    <script src='js/third-party/wglu/wglu-texture.js'></script>

    <script src='js/webxr-button.js'></script>
    <script src='js/webxr-scene.js'></script>
    <script src='js/webxr-scene-cube-sea.js'></script>
    <script src='js/webxr-samples-util.js'></script>
  </head>
  <body>
    <header>
      <details open>
        <summary>Framebuffer Scaling</summary>
        <p>
          This sample demonstrates scaling the framebuffer used for a WebXR layer
          at creation time to control the memory and fillrate required and improve
          performance or quality as needed.

          Framebuffer scaling should be used to make a performance/memory/quality
          tradeoff for the lifetime of the session. <br/>

          <select id='framebufferScaleSelect'>
            <option value='0.0' selected>Default - Allow the system to decide</option>
            <option value='1.2'>1.2 - 'Superscaling' for extreme quality</option>
            <option value='1.0'>1.0 - 1:1 pixel utilization</option>
            <option value='0.5'>0.5 - Low res for high performance</option>
          </select>
        </p>
      </details>
    </header>
    <main style='text-align: center;'>
      <p>Click 'Enter XR' to see content</p> 
    </main>
    <script>
      (function () {
      'use strict';

      let scaleSelect = document.getElementById('framebufferScaleSelect');

      // XR globals.
      let xrButton = null;
      let xrFrameOfRef = null;

      // WebGL scene globals.
      let gl = null;
      let scene = new WebXRSceneCubeSea();

      function initXR() {
        xrButton = new XRDeviceButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.requestDevice().then((device) => {
            xrButton.setDevice(device);
          });
        }
      }

      function onRequestSession(device) {
        device.requestSession({ exclusive: true }).then(onSessionStarted);
      }

      function onSessionStarted(session) {
        xrButton.setSession(session);

        session.addEventListener('end', onSessionEnded);

        gl = XRSamplesUtil.initWebGLContext({
          compatibleXRDevice: session.device
        });

        scene.setWebGLContext(gl);

        // This is the only meaningful change in this sample from xr-presentation.js.
        // It sets a requested scale to be applied to the framebuffer created
        // for the layer. The UA is allowed to ignore the request or adjust it
        // as needed. The scale of the framebuffer cannot be changed after the
        // layer is created, though the UA is allowed to resize the framebuffer
        // at any time.
        let scale = parseFloat(scaleSelect.value);
        session.baseLayer = new XRWebGLLayer(session, gl, {
          framebufferScaleFactor: scale
        });

        session.requestFrameOfReference('eyeLevel').then((frameOfRef) => {
          xrFrameOfRef = frameOfRef;

          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onEndSession(session) {
        session.end();
      }

      function onSessionEnded(event) {
        xrButton.setSession(null);

        gl = null;
      }

      function onXRFrame(t, frame) {
        let session = frame.session;
        let pose = frame.getDevicePose(xrFrameOfRef);

        scene.startFrame();

        session.requestAnimationFrame(onXRFrame);

        scene.drawXRFrame(frame, pose);

        scene.endFrame();
      }

      // Start the XR application.
      initXR();
      })();
    </script>
  </body>
</html>
