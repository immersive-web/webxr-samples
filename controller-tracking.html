<!doctype html>
<!--
Copyright 2017 The Chromium Authors. All rights reserved.
Use of this source code is governed by a BSD-style license that can be
found in the LICENSE file.
-->
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>

    <title>Controller Tracking</title>

    <link href='css/common.css' rel='stylesheet'></link>

    <script src='js/third-party/gl-matrix-min.js'></script>
    <script src='js/third-party/tiny-gltf2.js'></script>

    <script src='js/third-party/wglu/wglu-debug-geometry.js'></script>
    <script src='js/third-party/wglu/wglu-program.js'></script>
    <script src='js/third-party/wglu/wglu-stats.js'></script>
    <script src='js/third-party/wglu/wglu-texture.js'></script>

    <script src='js/webvr-button.js'></script>
    <script src='js/webvr-scene.js'></script>
    <script src='js/webvr-scene-gltf.js'></script>
    <script src='js/webvr-samples-util.js'></script>
    <script src='js/webvr-laser-renderer.js'></script>
  </head>
  <body>
    <header>
      <h1>Controller Tracking</h1>
      <p>
        This sample demonstrates basic tracking of VR controllers. It does not
        respond to button presses or other controller interactions.
      </p>
    </header>
    <script>
      (function () {
      'use strict';

      // VR globals.
      let vrButton = null;
      let vrExclusiveFrameOfRef = null;
      let vrNonExclusiveFrameOfRef = null;

      // WebGL scene globals.
      let gl = null;
      let scene = new WebVRSceneGLTF('media/gltf/Camp/WebVRCampsite.gltf');
      scene.standingStats(true); // Position the stats at standing height.
      let translatedViewMat = mat4.create();
      let translatedPoseMat = mat4.create();
      let controllerGeometries = [];
      let controllerLasers = [];

      const DEFAULT_HEIGHT = 1.65;

      // Utility function to determine if a ray and a sphere intersect.
      // Returns a positive value upon intersection.
      function raySphereIntersect(ray, sphere) {
        let L = vec3.create();

        let r2 = sphere.radius * sphere.radius;

        vec3.sub(L, sphere.center, ray.origin); 
        let tca = vec3.dot(L, ray.direction); 
        // if (tca < 0) return false;
        let d2 = vec3.dot(L, L) - tca * tca; 
        if (d2 > r2) return -1; 
        let thc = Math.sqrt(r2 - d2); 
        let t0 = tca - thc;
        let t1 = tca + thc;

        if (t0 > t1) {
          return t1 < 0 ? t0 : t1; 
        }
 
        return t0 < 0 ? t1 : t0;
      } 

      function initVR() {
        vrButton = new VRDeviceButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession
        });
        document.querySelector('header').appendChild(vrButton.domElement);

        if (navigator.vr) {
          navigator.vr.getDevices().then((devices) => {
            for (let device of devices) {
              vrButton.addDevice(device);
            }

            if (!devices.length)
              return;

            // In order for a non-exclusive session to be used we must provide
            // an outputContext, which indicates the canvas that will contain
            // results of the session's rendering.
            let outputCanvas = document.createElement('canvas');
            let ctx = outputCanvas.getContext('vrpresent');

            // Start up a non-exclusive session if possible.
            devices[0].requestSession({ outputContext: ctx })
                .then((session) => {
                  // Add the canvas to the document once we know that it will be
                  // rendered to.
                  document.body.appendChild(outputCanvas);
                  onSessionStarted(session);
                });
          });
        }
      }

      // Called when the user selects a device to present to. In response we
      // will request an exclusive session from that device.
      function onRequestSession(device) {
        device.requestSession({ exclusive: true }).then((session) => {
          vrButton.setSession(session);
          onSessionStarted(session);
        });
      }

      // Called when we've successfully acquired a VRSession. In response we
      // will set up the necessary session state and kick off the frame loop.
      function onSessionStarted(session) {
        session.addEventListener('end', onSessionEnded);
        session.addEventListener('select', onSelectGesture);

        if (!gl) {
          gl = VRSamplesUtil.initWebGLContext({
            compatibleVrDevice: session.device
          });

          scene.setWebGLContext(gl);
        }

        session.baseLayer = new VRWebGLLayer(session, gl);

        session.requestFrameOfReference('stage', {stageEmulationAllowed: true})
            .then((frameOfRef) => {
              if (session.exclusive) {
                vrExclusiveFrameOfRef = frameOfRef;
              } else {
                vrNonExclusiveFrameOfRef = frameOfRef;
              }
              session.requestFrame(onVRFrame);
            });
      }

      // Called when the user clicks the 'Exit VR' button. In response we end
      // the session.
      function onEndSession(session) {
        session.end();
      }

      // Called either when the user has explicitly ended the session (like in
      // onEndSession()) or when the UA has ended the session for any reason.
      // At this point the session object is no longer usable and should be
      // discarded.
      function onSessionEnded(event) {
        if (event.session.exclusive)
          vrButton.setSession(null);
      }

      function onControllerAdded(event) {
        console.log('Controller Added!');
      }

      function onSelectGesture(event) {
        // Reset the background color to a random value
        gl.clearColor(
            Math.random() * 0.5,
            Math.random() * 0.5,
            Math.random() * 0.5, 1.0);
      }

      // Called every time a VRSession requests that a new frame be drawn.
      function onVRFrame(frame) {
        let session = frame.session;
        // Ensure that we're using the right frame of reference for the session.
        let frameOfRef = session.exclusive ?
                         vrExclusiveFrameOfRef :
                         vrNonExclusiveFrameOfRef;
        let pose = frame.getDevicePose(frameOfRef);

        scene.startFrame();

        session.requestFrame(onVRFrame);

        let i = 0;
        if (pose) {
          let controllers = session.getControllers();

          for (let controller of controllers) {
            if (controllerGeometries.length < i+1) {
              controllerGeometries.push(scene.createDebugGeometry('axes'));
              controllerLasers.push(scene.createLaserPointer());
            }

            let geom = controllerGeometries[i];
            let laser = controllerLasers[i];
            ++i;

            let inputPose = frame.getInputPose(controller, frameOfRef);

            if (!inputPose) {
              geom.visible = false;
              laser.visible = false;
              continue;
            }

            let poseMat = inputPose.gripPoseMatrix;
            if (poseMat) {
              geom.visible = true;
              mat4.copy(geom.transform, poseMat);
            } else {
              geom.visible = false;
            }

            let pointerMat = inputPose.pointerPoseMatrix;
            if (pointerMat) {
              laser.visible = true;
              mat4.copy(laser.transform, pointerMat);
            } else {
              laser.visible = false;
            }

            /*for (let name in controller.elements) {
              let element = controller.elements[name];
              console.log('  * ' + name);
              console.log('    .value: ' + element.value);
              console.log('    .pressed: ' + element.pressed);
              console.log('    .touched: ' + element.touched);
              if (element.xAxis)
                console.log('    .xAxis: ' + element.xAxis);
              if (element.yAxis)
                console.log('    .yAxis: ' + element.yAxis);
            }*/
          }
        }

        // Turn off visualizations of controllers that aren't present any more.
        for (; i < controllerGeometries.length; ++i) {
          controllerGeometries[i].visible = false;
          controllerLasers[i].visible = false;
        }

        scene.drawVRFrame(frame, pose);

        scene.endFrame();
      }

      // Start the VR application.
      initVR();
      })();
    </script>
  </body>
</html>
