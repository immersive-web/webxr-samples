<!doctype html>
<!--
Copyright 2019 The Immersive Web Community Group

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
-->
<html>
  <head>
    <meta charset='utf-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1, user-scalable=no'>
    <meta name='mobile-web-app-capable' content='yes'>
    <meta name='apple-mobile-web-app-capable' content='yes'>

    <title>Controller State</title>

    <link href='css/common.css' rel='stylesheet'></link>
  </head>
  <body>
    <header>
      <details open>
        <summary>Controller State</summary>
        <p>
          This sample demonstrates using XRInputSource Gamepad button presses
          to change box color and joystick/touchpad input to move boxes in 2
          dimensions.
          <a class="back" href="./index.html">Back</a>
        </p>
      </details>
    </header>
    <script type="module">
      import {WebXRButton} from './js/util/webxr-button.js';
      import {Scene} from './js/render/scenes/scene.js';
      import {Renderer, createWebGLContext} from './js/render/core/renderer.js';
      import {Node} from './js/render/core/node.js';
      import {Gltf2Node} from './js/render/nodes/gltf2.js';
      import {SkyboxNode} from './js/render/nodes/skybox.js';
      import {BoxBuilder} from './js/render/geometry/box-builder.js';
      import {PbrMaterial} from './js/render/materials/pbr.js';
      import {mat4, vec3, quat} from './js/render/math/gl-matrix.js';
      import {QueryArgs} from './js/util/query-args.js';

      // If requested, use the polyfill to provide support for mobile devices
      // and devices which only support WebVR.
      import WebXRPolyfill from './js/third-party/webxr-polyfill/build/webxr-polyfill.module.js';
      if (QueryArgs.getBool('usePolyfill', false)) {
        let polyfill = new WebXRPolyfill();
      }

      // If requested, don't display the frame rate info.
      let hideStats = QueryArgs.getBool('hideStats', false);

      // XR globals.
      let xrButton = null;
      let xrRefSpace = null;

      // WebGL scene globals.
      let gl = null;
      let renderer = null;
      let scene = new Scene();
      if (hideStats) {
        scene.enableStats(false);
      }
      scene.addNode(new Gltf2Node({url: 'media/gltf/cube-room/cube-room.gltf'}));
      scene.standingStats(true);

      let floorSize = 10;
      let floorPosition = [0, -floorSize / 2 + 0.01, 0];
      let floorNode = null;

      let boxTable = {};

      const BOX_SIZE = 0.03;
      const BOX_MOTION_RANGE = 0.010;
      const BOX_SEPARATION = 0.04;
      const BOX_SET_HEIGHT = 0.03;
      const BOX_SET_DEPTH = -0.06;

      class GamepadBox extends Node {
        constructor(position) {
          super();

          this.position = position;
          let boxBuilder = new BoxBuilder();
          boxBuilder.pushCube([0, 0, 0], BOX_SIZE);
          let boxPrimitive = boxBuilder.finishPrimitive(renderer);
          let boxMaterial = new PbrMaterial();
          boxMaterial.baseColorFactor.value = [0.1, 0.1, 0.1, 1]; // grey
          this.renderPrimitive = renderer.createRenderPrimitive(boxPrimitive, boxMaterial);

          this.addRenderPrimitive(this.renderPrimitive);

          mat4.identity(this.matrix);
          mat4.translate(this.matrix, this.matrix, this.position);

          this._pressed = false;
        }

        set pressed(value) {
          if (value != this._pressed) {
            this._pressed = value;
            this.renderPrimitive.uniforms.baseColorFactor.value = this._pressed ?
              [1, 0, 0, 1] : // red
              [0.1, 0.1, 0.1, 1];  // grey
          }
        }

        get pressed() {
          return this._pressed;
        }

        // If this was something like a full-fledged game instead of just a
        // sample, timestamps should be used when calculating how much to move
        // on each frame. The way this code is right now, having a higher frame
        // rate means the boxes move faster.
        move(dx, dy) {
          mat4.identity(this.matrix);
          mat4.translate(this.matrix, this.matrix, this.position);
          mat4.translate(this.matrix, this.matrix, [
            dx * BOX_MOTION_RANGE,
            0,
            dy * BOX_MOTION_RANGE
          ]);
        }
      }

      class GamepadBoxSet extends Node {
        constructor(button_count) {
          super();

          // Place the boxes in a horizontal line
          this.boxes = [];
          let hl = (button_count - 1) * BOX_SEPARATION * 0.5;
          for (let x = 0; x < button_count; ++x) {
            let box = new GamepadBox([(x * BOX_SEPARATION) - hl, BOX_SET_HEIGHT, BOX_SET_DEPTH]);
            this.boxes.push(box);
            this.addNode(box);
          }
        }

        update_state(gamepad) {
          // A button press (pressing and then releasing a button) will change
          // the associated box's color from red to green (or from green to red
          // if it's currently green).
          for (let i = 0; i < gamepad.buttons.length; ++i) {
            this.boxes[i].pressed = gamepad.buttons[i].pressed;
          }

          if (gamepad.mapping == "xr-standard") {
            // Invert the y axis because gamepads follow the convention that -1
            // is up/forwards, but we want to have a forward joystick/touchpad
            // input result in forward motion for the box.

            // xr-standard Gamepads always have at least one touchpad/joystick.
            // Its button will always be in the second slot.
            this.boxes[1].move(gamepad.axes[0], gamepad.axes[1]);

            if (gamepad.axes.length >= 4 && gamepad.buttons.length >= 4) {
              // If an xr-standard Gamepad has a secondary touchpad/joystick, its
              // button will be in the 4th slot and it will use the second pair
              // of input axes.
              this.boxes[3].move(gamepad.axes[2], gamepad.axes[3]);
            }
          }
        }
      }

      function ProcessGamepad(gamepad, hand, pose) {
        if (!(hand in boxTable)) {
          const y_positions = {
            "left" : 1,
            "right" : 2,
            "none" : 3,
          };
          boxTable[hand] = new GamepadBoxSet(gamepad.buttons.length, y_positions[hand]);
          scene.addNode(boxTable[hand]);
        }

        boxTable[hand].update_state(gamepad);

        // Update the pose of the boxes to sync with the controller.
        if (pose) {
          boxTable[hand].matrix = pose.transform.matrix;
        }
      }

      // Don't bother starting an inline session in this sample since WebXR
      // gamepads are not available during inline sessions.
      function initXR() {
        xrButton = new WebXRButton({
          onRequestSession: onRequestSession,
          onEndSession: onEndSession
        });
        document.querySelector('header').appendChild(xrButton.domElement);

        if (navigator.xr) {
          navigator.xr.supportsSession('immersive-vr').then(() => {
            xrButton.enabled = true;
          });
        }
      }

      function initGL() {
        if (gl)
          return;

        gl = createWebGLContext({
          xrCompatible: true
        });
        document.body.appendChild(gl.canvas);

        function onResize() {
          gl.canvas.width = gl.canvas.clientWidth * window.devicePixelRatio;
          gl.canvas.height = gl.canvas.clientHeight * window.devicePixelRatio;
        }
        window.addEventListener('resize', onResize);
        onResize();

        renderer = new Renderer(gl);

        scene.setRenderer(renderer);
        scene.inputRenderer.setControllerMesh(new Gltf2Node({url: 'media/gltf/controller/controller.gltf'}));

        addFloorBox();
      }

      function addFloorBox() {
        let boxBuilder = new BoxBuilder();
        boxBuilder.pushCube([0, 0, 0], floorSize);
        let boxPrimitive = boxBuilder.finishPrimitive(renderer);

        let boxMaterial = new PbrMaterial();
        boxMaterial.baseColorFactor.value = [0.3, 0.3, 0.3, 1.0];
        let boxRenderPrimitive = renderer.createRenderPrimitive(boxPrimitive, boxMaterial);

        floorNode = new Node();
        floorNode.addRenderPrimitive(boxRenderPrimitive);
        floorNode.selectable = true;
        scene.addNode(floorNode);
        mat4.identity(floorNode.matrix);
        mat4.translate(floorNode.matrix, floorNode.matrix, floorPosition);
      }

      function onRequestSession() {
        navigator.xr.requestSession('immersive-vr').then((session) => {
          xrButton.setSession(session);
          session.isImmersive = true;
          onSessionStarted(session);
        });
      }

      function onSessionStarted(session) {
        session.addEventListener('end', () => xrButton.setSession(null));

        initGL();

        session.updateRenderState({
          baseLayer : new XRWebGLLayer(session, gl)
        });

        session.requestReferenceSpace('local-floor').then((refSpace) => {
          // Save the session-specific reference space.
          xrRefSpace = refSpace;
          session.requestAnimationFrame(onXRFrame);
        });
      }

      function onEndSession(session) {
        session.end();
      }

      function onXRFrame(time, frame) {
        let session = frame.session;
        let pose = frame.getViewerPose(xrRefSpace);
        scene.startFrame();
        session.requestAnimationFrame(onXRFrame);

        // Check for and respond to any gamepad state changes.
        for (let source of session.inputSources) {
          if (source.gamepad) {
            let pose = frame.getPose(source.gripSpace, xrRefSpace);
            ProcessGamepad(source.gamepad, source.handedness, pose);
          }
        }

        scene.updateInputSources(frame, xrRefSpace);
        scene.drawXRFrame(frame, pose);
        scene.endFrame();
      }

      // Start the XR application.
      initXR();
    </script>
  </body>
</html>